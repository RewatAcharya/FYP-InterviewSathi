@using InterviewSathi.Web.Models.Entities
@{
    var messages = ViewBag.Messages as List<PrivateMessage>;
}

<style>
     #messagesContainer {
        max-height: 300px; /* Adjust this value based on your layout */
        overflow-y: auto;
    } 

    .sent, .received {
        max-width: 70%;
        margin: 5px;
        padding: 10px;
        border-radius: 8px;
        word-wrap: break-word;
    }

    .sent {
        background-color: #4CAF50;
        color: white;
        align-self: flex-end;
    }

    .received {
        background-color: #f1f1f1;
        color: black;
        align-self: flex-start;
    }

    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        justify-content: center;
        align-items: center;
    }

    .modal-content {
        background-color: #fff;
        padding: 20px;
        text-align: center;
    }
</style>


@* <div id="callModal" class="modal">
    <div class="modal-content">
        <h2>Incoming Call</h2>
        <p>You have an incoming call from <span id="callerName"></span>.</p>
        <button onclick="answerCall()">Answer</button>
        <button onclick="rejectCall()">Reject</button>
    </div>
</div>
 *@
<h2>Chat with @Model.Name</h2>

<div class="container border m-3 p-4">
    <div class="row bg-light" id="msg" style="min-height: 400px; max-height: 400px; overflow-y: auto;">
        <div class="col-12 messagesContainer">
            <ul id="messagesList" class="list-unstyled">
                @foreach (var message in messages)
                {
                    if (message.SenderId == Model.Id)
                    {
                        <li class="received">Received: @message.MessageContent</li>
                    }
                    else
                    {
                        <li class="sent">Sent: @message.MessageContent</li>
                    }
                }
            </ul>
        </div>
    </div>
    <div id="chat-container">
        <div id="message-input" class="mt-3">
            <input type="text" id="ddlSelUser" value="@Model.Id" hidden>
            <input type="text" id="ddlSelUserName" value="@Model.Name" hidden>
            <div class="input-group">
                <input type="text" id="txtPrivateMessage" class="form-control" placeholder="Type your message...">
                <div class="input-group-append">
                    <button id="sendButton" class="btn btn-primary" onclick="sendPrivateMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>
</div>





























@* <div>
    <video id="localVideo" autoplay muted width="50%" height="100px"></video>
    <video id="remoteVideo" autoplay width="50%" height="100px"></video>
</div>
<div>
    <button onclick="startCall()">Start Video Call</button>
</div> *@
@* 
<script>
    var localVideo = document.getElementById("localVideo");
    var remoteVideo = document.getElementById("remoteVideo");
    var peerConnection;
    var callModal = document.getElementById("callModal");


    connection.on("ReceiveSignal", function (userFrom, userFromSignal) {
        console.log(`Received signal from ${userFrom}: ${userFromSignal}`);

        const signal = JSON.parse(userFromSignal);

        if (signal.iceCandidate) {
            // Add the incoming ICE candidate
            peerConnection.addIceCandidate(new RTCIceCandidate(signal.iceCandidate))
                .catch(error => console.error("Error adding ICE candidate:", error));
        } else if (signal.sdp) {
            // Set the remote SDP description
            peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp))
                .then(() => {
                    if (signal.sdp.type === "offer") {
                        // Create an SDP answer
                        return peerConnection.createAnswer();
                    }
                })
                .then(answer => peerConnection.setLocalDescription(answer))
                .then(() => {
                    // Send the SDP answer to the other peer
                    connection.invoke("SendSignal", userFrom, JSON.stringify({ "sdp": peerConnection.localDescription }));
                })
                .catch(error => console.error("Error handling SDP:", error));
        }
    });

    function showCallModal(callerName) {
        document.getElementById("callerName").innerText = callerName;
        callModal.style.display = "flex";
    }

    function hideCallModal() {
        callModal.style.display = "none";
    }

    function answerCall() {
        hideCallModal();
        // Implement the logic to answer the call
        console.log("User clicked 'Answer Call'");
        // Handle the answer logic here (e.g., starting the video call)
    }

    function rejectCall() {
        hideCallModal();
        // Implement the logic to reject the call
        console.log("User clicked 'Reject Call'");
        // Handle the reject logic here
    }



    function startCall() {
        let ddlSelUser = document.getElementById('ddlSelUser').value;

        // Create a new RTCPeerConnection
        peerConnection = new RTCPeerConnection();

        // Set up event handlers for ICE candidates and remote stream
        peerConnection.onicecandidate = event => {
            if (event.candidate) {
                // Send the ICE candidate to the other peer
                connection.invoke("SendSignal", ddlSelUser, JSON.stringify({ "iceCandidate": event.candidate }));
            }
        };

        // Set up event handler for receiving the remote stream
        peerConnection.ontrack = event => {
            // Display the remote stream in the remote video element
            remoteVideo.srcObject = event.streams[0];
        };

        // Obtain local media stream
        navigator.mediaDevices.getUserMedia({ video: true, audio: true })
            .then(localStream => {
                localVideo.srcObject = localStream;
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                // Set up a listener for incoming signals
                connection.on("ReceiveSignal", (userFrom, userFromSignal) => {
                    console.log(`Received signal from ${userFrom}: ${userFromSignal}`);

                    const signal = JSON.parse(userFromSignal);

                    if (signal.iceCandidate) {
                        // Add the incoming ICE candidate
                        peerConnection.addIceCandidate(new RTCIceCandidate(signal.iceCandidate))
                            .catch(error => console.error("Error adding ICE candidate:", error));
                    } else if (signal.sdp) {
                        // Set the remote SDP description
                        peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp))
                            .then(() => {
                                if (signal.sdp.type === "offer") {
                                    // Create an SDP answer
                                    return peerConnection.createAnswer();
                                }
                            })
                            .then(answer => peerConnection.setLocalDescription(answer))
                            .then(() => {
                                // Send the SDP answer to the other peer
                                connection.invoke("SendSignal", userFrom, JSON.stringify({ "sdp": peerConnection.localDescription }));
                            })
                            .catch(error => console.error("Error handling SDP:", error));
                    }
                });

                // Create an SDP offer
                return peerConnection.createOffer();
            })
            .then(offer => peerConnection.setLocalDescription(offer))
            .then(() => {
                // Send the SDP offer to the other peer
                connection.invoke("SendSignal", ddlSelUser, JSON.stringify({ "sdp": peerConnection.localDescription }));
            })
            .catch(error => {
                console.error("Error getting local stream or creating offer:", error);
            });
    }

    function pickupCall() {
        let ddlSelUser = document.getElementById('ddlSelUser').value;
        let ddlSelUserName = document.getElementById('ddlSelUserName').value;

        // Display the incoming call modal
        showCallModal(ddlSelUserName);
        // Create a new RTCPeerConnection
        peerConnection = new RTCPeerConnection();

        // Set up event handlers for ICE candidates and remote stream
        peerConnection.onicecandidate = event => {
            if (event.candidate) {
                // Send the ICE candidate to the other peer
                connection.invoke("SendSignal", ddlSelUser, JSON.stringify({ "iceCandidate": event.candidate }));
            }
        };

        // Set up event handler for receiving the remote stream
        peerConnection.ontrack = event => {
            // Display the remote stream in the remote video element
            remoteVideo.srcObject = event.streams[0];
        };

        // Obtain local media stream
        navigator.mediaDevices.getUserMedia({ video: true, audio: true })
            .then(localStream => {
                localVideo.srcObject = localStream;
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                // Set up a listener for incoming signals
                connection.on("ReceiveSignal", (userFrom, userFromSignal) => {
                    console.log(`Received signal from ${userFrom}: ${userFromSignal}`);

                    const signal = JSON.parse(userFromSignal);

                    if (signal.iceCandidate) {
                        // Add the incoming ICE candidate
                        peerConnection.addIceCandidate(new RTCIceCandidate(signal.iceCandidate))
                            .catch(error => console.error("Error adding ICE candidate:", error));
                    } else if (signal.sdp) {
                        // Set the remote SDP description
                        peerConnection.setRemoteDescription(new RTCSessionDescription(signal.sdp))
                            .then(() => {
                                if (signal.sdp.type === "offer") {
                                    // Create an SDP answer
                                    return peerConnection.createAnswer();
                                }
                            })
                            .then(answer => peerConnection.setLocalDescription(answer))
                            .then(() => {
                                // Send the SDP answer to the other peer
                                connection.invoke("SendSignal", userFrom, JSON.stringify({ "sdp": peerConnection.localDescription }));
                            })
                            .catch(error => console.error("Error handling SDP:", error));
                    }
                });

                // Create an SDP answer
                return peerConnection.createAnswer();
            })
            .then(answer => peerConnection.setLocalDescription(answer))
            .then(() => {
                // Send the SDP answer to the other peer
                connection.invoke("SendSignal", ddlSelUser, JSON.stringify({ "sdp": peerConnection.localDescription }));
            })
            .catch(error => {
                console.error("Error getting local stream or creating answer:", error);
            });
    }


    function hangUpCall() {
        // Close the peer connection and stop local media
        if (peerConnection) {
            peerConnection.close();
        }
        localVideo.srcObject.getTracks().forEach(track => track.stop());
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;
    }

    function showNotification(title, message) {
        if (Notification.permission === "granted") {
            var notification = new Notification(title, { body: message });
        } else if (Notification.permission !== "denied") {
            Notification.requestPermission().then(permission => {
                if (permission === "granted") {
                    var notification = new Notification(title, { body: message });
                }
            });
        }
    }


</script>

 *@